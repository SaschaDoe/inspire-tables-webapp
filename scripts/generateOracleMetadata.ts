import { glob } from 'glob';
import * as path from 'path';
import * as fs from 'fs';

interface OracleImage {
	id: string;
	oracleSet: number;
	number: number;
	imagePath: string;
	description: string;
}

interface OracleMetadata {
	totalImages: number;
	oracleSets: {
		[key: string]: OracleImage[];
	};
}

/**
 * Parse oracle text file to extract description
 */
function parseOracleText(textContent: string): string {
	// The text files contain detailed oracle information
	// We'll return the full content for now, but could parse it more if needed
	return textContent.trim();
}

/**
 * Generate oracle metadata from resources folder
 */
async function generateOracleMetadata() {
	const resourcesPath = path.join(process.cwd(), 'resources', 'Oracle Images');
	const staticOraclePath = path.join(process.cwd(), 'static', 'oracle-images');

	// Create static oracle directory if it doesn't exist
	if (!fs.existsSync(staticOraclePath)) {
		fs.mkdirSync(staticOraclePath, { recursive: true });
	}

	const metadata: OracleMetadata = {
		totalImages: 0,
		oracleSets: {}
	};

	// Find all oracle sets
	const oracleSets = fs
		.readdirSync(resourcesPath)
		.filter(
			(name) =>
				fs.statSync(path.join(resourcesPath, name)).isDirectory() && name.startsWith('Oracle_')
		)
		.sort();

	console.log(`Found ${oracleSets.length} oracle sets`);

	for (const oracleSetName of oracleSets) {
		const setNumber = parseInt(oracleSetName.replace('Oracle_', ''));
		const oracleSetPath = path.join(resourcesPath, oracleSetName);
		const staticSetPath = path.join(staticOraclePath, `oracle-${setNumber}`);

		// Create static set directory
		if (!fs.existsSync(staticSetPath)) {
			fs.mkdirSync(staticSetPath, { recursive: true });
		}

		const images: OracleImage[] = [];

		// Find all subdirectories in this oracle set
		const subDirs = fs
			.readdirSync(oracleSetPath)
			.filter((name) => fs.statSync(path.join(oracleSetPath, name)).isDirectory())
			.sort();

		console.log(`  Oracle ${setNumber}: Found ${subDirs.length} images`);

		for (const subDir of subDirs) {
			const subDirPath = path.join(oracleSetPath, subDir);

			// Find the image and text files
			const files = fs.readdirSync(subDirPath);
			const iconFile = files.find((f) => f.endsWith('_icon.png'));
			const textFile = files.find((f) => f.endsWith('_text.txt'));

			if (iconFile && textFile) {
				const number = parseInt(iconFile.replace('_icon.png', ''));
				const iconPath = path.join(subDirPath, iconFile);
				const textPath = path.join(subDirPath, textFile);

				// Read the description
				const description = parseOracleText(fs.readFileSync(textPath, 'utf-8'));

				// Copy image to static folder
				const staticImagePath = path.join(staticSetPath, iconFile);
				fs.copyFileSync(iconPath, staticImagePath);

				// Create metadata entry
				images.push({
					id: `oracle-${setNumber}-${number}`,
					oracleSet: setNumber,
					number: number,
					imagePath: `/oracle-images/oracle-${setNumber}/${iconFile}`,
					description: description
				});

				metadata.totalImages++;
			}
		}

		metadata.oracleSets[`oracle-${setNumber}`] = images.sort((a, b) => a.number - b.number);
	}

	// Write metadata file
	const outputPath = path.join(process.cwd(), 'src', 'lib', 'data', 'oracleMetadata.ts');

	const fileContent = `// AUTO-GENERATED FILE - DO NOT EDIT MANUALLY
// Generated by scripts/generateOracleMetadata.ts
// Run 'npm run generate:oracle-metadata' to regenerate

export interface OracleImage {
	id: string;
	oracleSet: number;
	number: number;
	imagePath: string;
	description: string;
}

export interface OracleMetadata {
	totalImages: number;
	oracleSets: {
		[key: string]: OracleImage[];
	};
}

export const oracleMetadata: OracleMetadata = ${JSON.stringify(metadata, null, 2)};

/**
 * Get all oracle images as a flat array
 */
export function getAllOracleImages(): OracleImage[] {
	return Object.values(oracleMetadata.oracleSets).flat();
}

/**
 * Get oracle images from a specific set
 */
export function getOracleSet(setNumber: number): OracleImage[] {
	return oracleMetadata.oracleSets[\`oracle-\${setNumber}\`] || [];
}

/**
 * Get a random oracle image
 */
export function getRandomOracleImage(): OracleImage {
	const allImages = getAllOracleImages();
	const randomIndex = Math.floor(Math.random() * allImages.length);
	return allImages[randomIndex];
}

/**
 * Get a random oracle image from a specific set
 */
export function getRandomOracleImageFromSet(setNumber: number): OracleImage {
	const setImages = getOracleSet(setNumber);
	if (setImages.length === 0) {
		throw new Error(\`Oracle set \${setNumber} not found\`);
	}
	const randomIndex = Math.floor(Math.random() * setImages.length);
	return setImages[randomIndex];
}
`;

	fs.writeFileSync(outputPath, fileContent, 'utf-8');

	console.log(`\nâœ… Generated oracle metadata:`);
	console.log(`   Total images: ${metadata.totalImages}`);
	console.log(`   Oracle sets: ${Object.keys(metadata.oracleSets).length}`);
	console.log(`   Output file: ${outputPath}`);
	console.log(`   Static images: ${staticOraclePath}`);
}

// Run the generator
generateOracleMetadata().catch((error) => {
	console.error('Error generating oracle metadata:', error);
	process.exit(1);
});
