import { Creator } from '../base/creator';
import { City } from './city';
import { TownSizeTable } from '$lib/tables/townTables/townSizeTable';
import { TownFameTable } from '$lib/tables/townTables/townFameTable';
import { TownEventTable } from '$lib/tables/townTables/townEventTable';
import { CityPopulationManager } from '$lib/simulation/managers/CityPopulationManager';
import { CityProductionManager } from '$lib/simulation/managers/CityProductionManager';
import { CityExpansionManager } from '$lib/simulation/managers/CityExpansionManager';

/**
 * CityCreator - Dual-mode city creation for RPG and Simulation contexts
 *
 * Phase 1.7: Replaces SettlementCreator, provides unified city creation
 *
 * - create(): Creates RPG-mode city (isSimulationGenerated = false)
 * - createFromSimulation(): Creates simulation-mode city (isSimulationGenerated = true)
 */
export class CityCreator extends Creator<City> {
	/**
	 * Create RPG-mode city (manual creation for RPG content)
	 * This replaces the old SettlementCreator.create() functionality
	 */
	create(): City {
		const city = new City();

		// Mark as RPG-generated
		city.isSimulationGenerated = false;

		// Generate RPG properties (from old Settlement logic)
		city.size = new TownSizeTable().roleWithCascade(this.dice).text;
		city.fame = new TownFameTable().roleWithCascade(this.dice).text;

		// Generate 1-3 recent narrative events
		const numEvents = this.dice.rollInterval(1, 3);
		city.rpgEvents = [];
		for (let i = 0; i < numEvents; i++) {
			city.rpgEvents.push(new TownEventTable().roleWithCascade(this.dice).text);
		}

		// Calculate population based on size (RPG scale: 100-2,000,000)
		city.population = this.calculatePopulationFromSize(city.size);

		// Generate name
		city.name = this.generateName(city);

		// Generate RPG description
		city.rpgDescription = this.generateRPGDescription(city);
		city.description = city.rpgDescription; // Unified description

		return city;
	}

	/**
	 * Create simulation-mode city (generated by SimulationEngine)
	 *
	 * @param name City name
	 * @param ownerNationId Nation that owns this city
	 * @param founderNationId Nation that founded this city
	 * @param hexTileId DetailedHexTile ID where city is located
	 * @param parentPlanetId Planet ID this city belongs to
	 * @param coordinates {x, y} global coordinates on world map
	 * @param foundedYear Simulation year when city was founded
	 * @param isCapital Whether this is the nation's capital
	 * @returns Initialized City entity ready for simulation
	 */
	static createForSimulation(params: {
		name: string;
		ownerNationId: string;
		founderNationId: string;
		hexTileId: string;
		parentPlanetId: string;
		coordinates: { x: number; y: number };
		foundedYear: number;
		isCapital?: boolean;
	}): City {
		const city = new City();

		// Mark as simulation-generated
		city.isSimulationGenerated = true;

		// Set basic properties
		city.name = params.name;
		city.ownerNationId = params.ownerNationId;
		city.founderNationId = params.founderNationId;
		city.foundedYear = params.foundedYear;
		city.isCapital = params.isCapital || false;

		// Set location (this also reinitializes the expansion manager)
		city.setLocation(params.hexTileId, params.parentPlanetId, params.coordinates);

		// Initialize simulation properties
		city.population = 1; // Start at pop 1 (Civ 5 style)
		city.foodStored = 0;
		city.calculateFoodNeededForGrowth();

		// Calculate initial yields (city center provides 2 food, 1 production)
		city.calculateYields();

		// Also populate RPG properties so Settlement Overview shows values
		city.size = CityCreator.calculateSizeFromPopulation(city.population);
		city.fame = new TownFameTable().roleWithCascade().text;

		// Generate description that works for both views
		city.description = `A ${city.size} known for ${city.fame}. Founded in year ${params.foundedYear}.`;
		city.rpgDescription = city.description;

		return city;
	}

	/**
	 * Calculate size category from population (for simulation cities)
	 * This is the reverse of calculatePopulationFromSize
	 */
	static calculateSizeFromPopulation(population: number): string {
		// Civ 5 pop 1 = ~10,000 people equivalent in real terms
		// But for RPG flavor, we map simulation pop to size categories
		if (population <= 1) return 'hamlet';
		if (population <= 3) return 'village';
		if (population <= 6) return 'town';
		if (population <= 10) return 'large town';
		if (population <= 15) return 'city';
		if (population <= 25) return 'large city';
		return 'metropolis';
	}

	/**
	 * Update RPG properties when simulation population changes
	 * Call this after population changes to keep size in sync
	 */
	static updateRPGPropertiesFromSimulation(city: City): void {
		if (!city.isSimulationGenerated) return;

		const newSize = CityCreator.calculateSizeFromPopulation(city.population);
		if (city.size !== newSize) {
			city.size = newSize;
			// Update description to reflect new size
			city.description = `A ${city.size} known for ${city.fame || 'its founding'}. Population: ${city.population}.`;
			city.rpgDescription = city.description;
		}
	}

	/**
	 * Calculate population from size category (RPG scale)
	 */
	private calculatePopulationFromSize(size: string): number {
		const populations: Record<string, [number, number]> = {
			hamlet: [20, 100],
			village: [100, 1000],
			town: [1000, 5000],
			'large town': [5000, 20000],
			city: [20000, 100000],
			'large city': [100000, 500000],
			metropolis: [500000, 2000000]
		};

		const range = populations[size.toLowerCase()] || [100, 1000];
		return this.dice.rollInterval(range[0], range[1]);
	}

	/**
	 * Generate city name
	 */
	private generateName(city: City): string {
		const prefixes = ['North', 'South', 'East', 'West', 'New', 'Old', 'High', 'Low'];
		const suffixes = [
			'haven',
			'port',
			'ford',
			'ton',
			'shire',
			'dale',
			'wick',
			'stead',
			'bridge',
			'castle',
			'crest',
			'vale'
		];

		const usePrefix = this.dice.random() > 0.5;
		const prefix = usePrefix
			? prefixes[Math.floor(this.dice.random() * prefixes.length)]
			: '';
		const suffix = suffixes[Math.floor(this.dice.random() * suffixes.length)];

		return usePrefix ? `${prefix}${suffix}` : this.capitalize(suffix);
	}

	/**
	 * Generate RPG description
	 */
	private generateRPGDescription(city: City): string {
		const eventText =
			city.rpgEvents && city.rpgEvents.length > 0
				? ` Recent events: ${city.rpgEvents.join(', ')}.`
				: '';

		return `A ${city.size} known for ${city.fame}. Population: approximately ${city.population}.${eventText}`;
	}

	/**
	 * Capitalize first letter of string
	 */
	private capitalize(str: string): string {
		return str.charAt(0).toUpperCase() + str.slice(1);
	}
}
